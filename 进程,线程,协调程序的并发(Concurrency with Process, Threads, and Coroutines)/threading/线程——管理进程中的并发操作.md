目标：管理多个执行线程
使用多线程可以使程序在一个进程空间内运行并发地执行多个操作。
##线程对象
使用一个线程最简单的方式就是用一个目标函数去实例化它并调用start()函数让它开始工作。
```python
# threading_simple.py
import threading


def worker():
    """thread worker function"""
    print('Worker')


threads = []
for i in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()
```
上面程序将会输入五行"Worker"。
```bash
$ python3 threading_simple.py

Worker
Worker
Worker
Worker
Worker
```
##处理当前线程
使用参数来标识或者命名线程将会比较麻烦而且没有这个必要。每一个线程实例都会有一个默认的线程名，而且可以在线程创建的时候修改这个默认值。命名线程在具有不同操作的多个服务线程的服务器进程中十分有用。
```python
# threading_names.py
import threading
import time


def worker():
    print(threading.current_thread().getName(), 'Starting')
    time.sleep(0.2)
    print(threading.current_thread().getName(), 'Exiting')


def my_service():
    print(threading.current_thread().getName(), 'Starting')
    time.sleep(0.3)
    print(threading.current_thread().getName(), 'Exiting')


t = threading.Thread(name='my_service', target=my_service)
w = threading.Thread(name='worker', target=worker)
w2 = threading.Thread(target=worker)  # use default name

w.start()
w2.start()
t.start()

```
调试输出在每一行输出了当前线程的名字。线程名称列中的"Thread-1"对应未命名线程w2。
```bash
$ python3 threading_names.py

worker Starting
Thread-1 Starting
my_service Starting
worker Exiting
Thread-1 Exiting
my_service Exiting
```
大多数程序不会使用打印信息来调试。logging模块支持通过格式化代码`%(threadName)s`在每一条日志信息中嵌入线程名称。在日志信息中加入线程名称，有利于我们追踪信息的来源。
```python
# threading_names_log.py
import logging
import threading
import time


def worker():
    logging.debug('Starting')
    time.sleep(0.2)
    logging.debug('Exiting')


def my_service():
    logging.debug('Starting')
    time.sleep(0.3)
    logging.debug('Exiting')


logging.basicConfig(
    level=logging.DEBUG,
    format='[%(levelname)s] (%(threadName)-10s) %(message)s',
)

t = threading.Thread(name='my_service', target=my_service)
w = threading.Thread(name='worker', target=worker)
w2 = threading.Thread(target=worker)  # use default name

w.start()
w2.start()
t.start()
```
logging是线程安全的，所以来自不同线程的消息在输出中保持不同。
```bash
$ python3 threading_names_log.py

[DEBUG] (worker    ) Starting
[DEBUG] (Thread-1  ) Starting
[DEBUG] (my_service) Starting
[DEBUG] (worker    ) Exiting
[DEBUG] (Thread-1  ) Exiting
[DEBUG] (my_service) Exiting
```
##守护线程 vs 非守护线程
到目前为止，我们的示例程序都会隐式地等待所有线程完成他们的工作之后再退出。有时，程序会产生一个线程作为守护线程，它不会阻止主程序的退出。在服务器中，可能没有简单的方式中断一个线程，这时使用守护线程是十分有用的，或者需要在线程工作到一半的时候挂掉而不会丢失或损坏数据（例如，在服务监控工具中产生“心跳信号”的线程）。将一个线程标志为守护线程，可以在构建它的时候传递参数`daemon=True`，或者调用set_daemon()使用参数True。默认线程不是守护线程。
```python
# threading_daemon.py
import threading
import time
import logging


def daemon():
    logging.debug('Starting')
    time.sleep(0.2)
    logging.debug('Exiting')


def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

d = threading.Thread(name='daemon', target=daemon, daemon=True)

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()
```
上例的输出中没有守护线程的"Exiting"，因为所有的非守护线程（包括主线程）在守护线程调用sleep()唤醒之前都退出了。
```bash
$ python3 threading_daemon.py

(daemon    ) Starting
(non-daemon) Starting
(non-daemon) Exiting
```
等待守护线程跑完，可以使用join()方法。
```python
threading_daemon_join.py
import threading
import time
import logging


def daemon():
    logging.debug('Starting')
    time.sleep(0.2)
    logging.debug('Exiting')


def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

d = threading.Thread(name='daemon', target=daemon, daemon=True)

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

d.join()
t.join()
```
使用join()去等待守护线程退出，意味着它将输出“Exiting”信息。
```bash
$ python3 threading_daemon_join.py

(daemon    ) Starting
(non-daemon) Starting
(non-daemon) Exiting
(daemon    ) Exiting
```
默认地，join()会无限期地阻塞。你也可以传入一个浮点数作为等待线程变为非活动状态等待的秒数。如果在超过这个设定时间后，线程仍未完成，join()会自动返回。
```python
threading_daemon_join_timeout.py
import threading
import time
import logging


def daemon():
    logging.debug('Starting')
    time.sleep(0.2)
    logging.debug('Exiting')


def non_daemon():
    logging.debug('Starting')
    logging.debug('Exiting')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

d = threading.Thread(name='daemon', target=daemon, daemon=True)

t = threading.Thread(name='non-daemon', target=non_daemon)

d.start()
t.start()

d.join(0.1)
print('d.isAlive()', d.isAlive())
t.join()
```
因为传入的超时等待时间小于守护线程在线程中休眠的时间，所以线程在join()返回后依旧还“活着”。
```bash
$ python3 threading_daemon_join_timeout.py

(daemon    ) Starting
(non-daemon) Starting
(non-daemon) Exiting
d.isAlive() True
```
##枚举所有线程
没有必要为所有的守护线程维护一个显式的句柄来确保在主进程退出之前这些守护线程都完成了。enumerate()能够返回一个包含所有活动线程实例的列表。这个列表同时也包括了当前线程，因为等待当前线程结束会进入一种死锁状态，所以必须跳过。
```python
# threading_enumerate.py
import random
import threading
import time
import logging


def worker():
    """thread worker function"""
    pause = random.randint(1, 5) / 10
    logging.debug('sleeping %0.2f', pause)
    time.sleep(pause)
    logging.debug('ending')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

for i in range(3):
    t = threading.Thread(target=worker, daemon=True)
    t.start()

main_thread = threading.main_thread()
for t in threading.enumerate():
    if t is main_thread:
        continue
    logging.debug('joining %s', t.getName())
    t.join()
```
因为worker线程休眠的时间是随机的，所以这个程序的退出时间也是不确定的。
```bash
$ python3 threading_enumerate.py

(Thread-1  ) sleeping 0.20
(Thread-2  ) sleeping 0.30
(Thread-3  ) sleeping 0.40
(MainThread) joining Thread-1
(Thread-1  ) ending
(MainThread) joining Thread-3
(Thread-2  ) ending
(Thread-3  ) ending
(MainThread) joining Thread-2
```
##派生线程
开始时，线程会做一些初始化工作，然后调用run()，在run()中调用传递给构造函数的目标函数。如果要创建一个Thread的子类，需要覆盖run()来完成所需要的工作。
```python
# threading_subclass.py
import threading
import logging


class MyThread(threading.Thread):

    def run(self):
        logging.debug('running')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

for i in range(5):
    t = MyThread()
    t.start()
```
忽略run()的返回值。
```bash
$ python3 threading_subclass.py

(Thread-1  ) running
(Thread-2  ) running
(Thread-3  ) running
(Thread-4  ) running
(Thread-5  ) running
```
因为传递给Thread构造函数的args和kwargs值是存储在私有变量（前缀'__'的变量）中的。，子类并不能简单地访问这些变量。如果要向一个定制线程传递参数，应该在重新定义的构造函数中将这些值保存在一个子类可见的实例属性中。

```python
# threading_subclass_args.py
import threading
import logging


class MyThreadWithArgs(threading.Thread):

    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, *, daemon=None):
        super().__init__(group=group, target=target, name=name,
                         daemon=daemon)
        self.args = args
        self.kwargs = kwargs

    def run(self):
        logging.debug('running with %s and %s',
                      self.args, self.kwargs)


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

for i in range(5):
    t = MyThreadWithArgs(args=(i,), kwargs={'a': 'A', 'b': 'B'})
    t.start()
```
MyThreadWithArgs使用的API和Thread一样，但这个类可以简单地通过修改构造函数方法，使其可以接收更多与线程用途直接相关的不同参数，这一点类似于其他定制类。
```bash
$ python3 threading_subclass_args.py

(Thread-1  ) running with (0,) and {'b': 'B', 'a': 'A'}
(Thread-2  ) running with (1,) and {'b': 'B', 'a': 'A'}
(Thread-3  ) running with (2,) and {'b': 'B', 'a': 'A'}
(Thread-4  ) running with (3,) and {'b': 'B', 'a': 'A'}
(Thread-5  ) running with (4,) and {'b': 'B', 'a': 'A'}
```
##定时器线程
线程子类的一个示例是由Timer提供的，也包括在Threading中。定时器线程会在一段时间延时之后再开始它的线程工作，并且也能在定时周期内的任何时间点停止。
```python
# threading_timer.py
import threading
import time
import logging


def delayed():
    logging.debug('worker running')


logging.basicConfig(
    level=logging.DEBUG,
    format='(%(threadName)-10s) %(message)s',
)

t1 = threading.Timer(0.3, delayed)
t1.setName('t1')
t2 = threading.Timer(0.3, delayed)
t2.setName('t2')

logging.debug('starting timers')
t1.start()
t2.start()

logging.debug('waiting before canceling %s', t2.getName())
time.sleep(0.2)
logging.debug('canceling %s', t2.getName())
t2.cancel()
logging.debug('done')

```
在上面的示例中，第二个定时器线程内容永远都不会执行，第一个定时器线程会在主程序执行完之后再执行线程工作。由于它不是一个守护线程，所有在主线程退出以后它也会隐式地退出。
```bash
$ python3 threading_timer.py

(MainThread) starting timers
(MainThread) waiting before canceling t2
(MainThread) canceling t2
(MainThread) done
(t1        ) worker running
```





































